/* global CHR, importScripts, application */

/**
 * Closure that holds the evaluated preamble
 *   and CHR handler.
 *
 * @param {Object} parsed  Object generated by CHR parser
 */
function CHRWorker (parsed, oldChr, opts) {
  opts = opts || {}
  opts.persistentStore = opts.persistentStore || false

  // evaluate given preamble
  var preamble = parsed.preamble || ''
  eval(preamble) // eslint-disable-line no-eval

  // replacements must be evaluated in this context
  // to access the methods specified in the preamble
  var replacements = parsed.replacements.map(function (replacement) {
    return eval('(' + replacement.expr.original + ')') // eslint-disable-line no-eval
  })

  // save store if it should remain persistent
  var constructorOptions = {}
  var newStore = false
  if (opts.persistentStore && oldChr) {
    constructorOptions.store = oldChr.Store
    newStore = true
  }

  // compile given CHR source code
  var chr = new CHR(constructorOptions)
  chr(parsed, replacements)

  // set breakpoints
  setBreakpoints()

  application.remote.setInfo({
    functors: chr.Functors.sort(functorComparator)
  })

  function callQuery (queries) {
    var promise = Promise.resolve()
    queries.forEach(function (query) {
      var queryCall = query.original

      // fix fore some browsers
      queryCall = queryCall.replace(/console\.log/g, 'console.log.bind(console)')

      queryCall = '(chr.' + queryCall + ')'
      if (query.arity === 0) {
        queryCall += '()'
      }

      promise = promise.then(function () {
        try {
          return eval('(' + queryCall + ')') // eslint-disable-line no-eval
        } catch (e) {
          application.remote.queryFinished({
            error: e.toString()
          })

          return null
        }
      })
    })

    promise.then(function () {
      application.remote.queryFinished({
        store: getStore()
      })
    })
  }

  if (newStore) {
    chr.Store.removeAllListeners('add')
    chr.Store.removeAllListeners('remove')
    chr.Store.on('add', function (data) {
      application.remote.storeEvent({
        event: 'store:add',
        constraint: data,
        constraintString: data.toString()
      })
    })
    chr.Store.on('remove', function (data) { 
      application.remote.storeEvent({
        event: 'store:remove',
        constraint: data,
        constraintString: data.toString()
      })
    })
  }

  function killConstraint (id) {
    chr.Store.kill(id)
  }

  var breakpointCallback = function () {}

  function setBreakpoints () {
    chr.Rules.SetBreakpoints(function (data, callback) {
      breakpointCallback = callback

      data.store = getStore()

      if (data.constraint) {
        data.constraint = data.constraint.toString()
      }

      application.remote.breakpoint(data)
    })
  }

  function continueBreakpoint () {
    breakpointCallback()
  }

  function getStore () {
    var store = []
    chr.Store.forEach(function (constraint) {
      if (!constraint.alive) {
        return
      }

      store.push({
        id: constraint.id,
        string: constraint.toString()
      })
    })

    return store
  }

  // return access methods
  return {
    chr: chr,
    functors: chr.Functors,
    callQuery: callQuery,
    killConstraint: killConstraint,
    continueBreakpoint: continueBreakpoint,
    getStore: getStore,
    test: function () {
      console.log('Test called', arguments)
    }
  }
}

var worker

var api = {
  loadCHR: function (url) {
    // load CHR.js into variable `CHR` in plugin context
    importScripts(url)
  },
  setSource: function (parsed, opts) {
    var oldChr = (worker && worker.chr ? worker.chr : null)
    worker = CHRWorker(parsed, oldChr, opts)
  },
  callQuery: function (parsed) {
    worker.callQuery(parsed)
  },
  killConstraint: function (id) {
    worker.killConstraint(id)
  },
  continueBreakpoint: function () {
    worker.continueBreakpoint()
  },
  getStore: function (callback) {
    var store = worker.getStore()
    callback(store)
  }
}

application.setInterface(api)

function functorComparator (a, b) {
  a = a.split('/')
  b = b.split('/')

  if (a[0] < b[0]) {
    return -1
  }
  if (a[0] > b[0]) {
    return 1
  }

  a = parseInt(a[1], 10)
  b = parseInt(b[1], 10)

  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}
